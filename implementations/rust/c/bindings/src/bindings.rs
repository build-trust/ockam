/* automatically generated by rust-bindgen */

pub const OCKAM_VAULT_SHARED_SECRET_LENGTH: u32 = 32;
pub const OCKAM_VAULT_SHA256_DIGEST_LENGTH: u32 = 32;
pub const OCKAM_VAULT_AES128_KEY_LENGTH: u32 = 16;
pub const OCKAM_VAULT_AES256_KEY_LENGTH: u32 = 32;
pub const OCKAM_VAULT_AEAD_AES_GCM_TAG_LENGTH: u32 = 16;
pub const OCKAM_VAULT_CURVE25519_PUBLICKEY_LENGTH: u32 = 32;
pub const OCKAM_VAULT_P256_PUBLICKEY_LENGTH: u32 = 65;
pub const OCKAM_VAULT_P256_PRIVATEKEY_LENGTH: u32 = 32;
pub const OCKAM_VAULT_HKDF_SHA256_OUTPUT_LENGTH: u32 = 32;
pub const OCKAM_VAULT_FEAT_RANDOM: u32 = 1;
pub const OCKAM_VAULT_FEAT_SHA256: u32 = 2;
pub const OCKAM_VAULT_FEAT_SECRET_ECDH: u32 = 4;
pub const OCKAM_VAULT_FEAT_HKDF_SHA256: u32 = 8;
pub const OCKAM_VAULT_FEAT_AEAD_AES_GCM: u32 = 16;
pub const OCKAM_VAULT_FEAT_ALL: u32 = 31;
pub const OCKAM_VAULT_ATECC608A_IO_PROTECTION_KEY_SIZE: u32 = 32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ockam_error_t {
    pub code: ::std::os::raw::c_int,
    pub domain: *const ::std::os::raw::c_char,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ockam_error_code_t {
    OCKAM_ERROR_NONE = 0,
}
extern "C" {
    pub static OCKAM_MEMORY_INTERFACE_ERROR_DOMAIN: *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ockam_error_code_memory_interface_t {
    OCKAM_MEMORY_INTERFACE_ERROR_INVALID_PARAM = 1,
}
extern "C" {
    #[doc = " @brief   Deinitialize the specified ockam memory object."]
    #[doc = " @param   memory[in]  The ockam memory object to deinitialize."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory received."]
    pub fn ockam_memory_deinit(memory: *mut ockam_memory_t) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Allocate memory from the specified memory module"]
    #[doc = " @param   memory[in]      The ockam memory object to use."]
    #[doc = " @param   buffer[in]      Pointer to a buffer to allocate."]
    #[doc = " @param   buffer_size[in] Buffer size (in bytes) to allocate."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory or buffer received."]
    #[doc = " @return  MEMORY_ERROR_INVALID_SIZE if buffer_size <=0."]
    #[doc = " @return  MEMORY_ERROR_ALLOC_FAIL if unable to allocate the desired buffer."]
    pub fn ockam_memory_alloc_zeroed(
        memory: *mut ockam_memory_t,
        buffer: *mut *mut ::core::ffi::c_void,
        buffer_size: usize,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Free the specified buffer."]
    #[doc = " @param   memory[in]      The ockam memory object to use."]
    #[doc = " @param   buffer[in]      Buffer to free. Must have been allocated from alloc()."]
    #[doc = " @param   buffer_size[in] Size of the buffer that was allocated. Must match what was specified in alloc."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory or buffer received."]
    #[doc = " @return  MEMORY_ERROR_INVALID_SIZE if buffer_size <=0."]
    pub fn ockam_memory_free(
        memory: *mut ockam_memory_t,
        buffer: *mut ::core::ffi::c_void,
        buffer_size: usize,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Set a set_size number of bytes to the buffer with value."]
    #[doc = " @param   memory[in]    The ockam memory object to use."]
    #[doc = " @param   buffer[out]   The buffer to fill with the specified value."]
    #[doc = " @param   value[in]     The value to set the the buffer with."]
    #[doc = " @param   set_size[in]  The number of bytes to set buffer with value."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory or buffer received."]
    #[doc = " @return  MEMORY_ERROR_INVALID_SIZE if set_size <=0."]
    pub fn ockam_memory_set(
        memory: *mut ockam_memory_t,
        buffer: *mut ::core::ffi::c_void,
        value: u8,
        set_size: usize,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Copy data from the source buffer to the destination buffer."]
    #[doc = " @param   memory[in]        The ockam memory object to use."]
    #[doc = " @param   destination[out]  Buffer to place the copied data into. Can not overlap with source."]
    #[doc = " @param   source[in]        Buffer to copy data from."]
    #[doc = " @param   copy_size[in]     Size of data to copy."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory, destination or source received."]
    #[doc = " @return  MEMORY_ERROR_INVALID_SIZE if copy_size <=0."]
    pub fn ockam_memory_copy(
        memory: *mut ockam_memory_t,
        destination: *mut ::core::ffi::c_void,
        source: *const ::core::ffi::c_void,
        copy_size: usize,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Move move_size bytes from source to destination."]
    #[doc = " @param   memory[in]        The ockam memory object to use."]
    #[doc = " @param   destination[out]  Buffer to place the moved data into. May overlap with source."]
    #[doc = " @param   source[in]        Buffer to move data from."]
    #[doc = " @param   move_size[in]     Size of data to move."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory, destination or source received."]
    #[doc = " @return  MEMORY_ERROR_INVALID_SIZE if move_size <=0."]
    pub fn ockam_memory_move(
        memory: *mut ockam_memory_t,
        destination: *mut ::core::ffi::c_void,
        source: *mut ::core::ffi::c_void,
        move_size: usize,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Compare two blocks of memory."]
    #[doc = " @param   memory[in]       The ockam memory object to use."]
    #[doc = " @param   res[out]         Result. <0\tthe first byte that does not match has a lower value in lhs than in rhs."]
    #[doc = "0\tthe contents of both memory blocks are equal."]
    #[doc = ">0\tthe first byte that does not match has a greater value in lhs than in rhs."]
    #[doc = " @param   lhs[in]          Pointer to first block of memory."]
    #[doc = " @param   rhs[in]          Pointer to second block of memory."]
    #[doc = " @param   buffer_size[in]  Size of memory blocks."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory, res, lhs or rhs received."]
    pub fn ockam_memory_compare(
        memory: *mut ockam_memory_t,
        res: *mut ::std::os::raw::c_int,
        lhs: *const ::core::ffi::c_void,
        rhs: *const ::core::ffi::c_void,
        move_size: usize,
    ) -> ockam_error_t;
}
#[doc = " @struct  ockam_memory_dispatch_table"]
#[doc = " @brief   The Ockam Memory implementation functions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ockam_memory_dispatch_table_t {
    #[doc = " @brief   Deinitialize the specified ockam memory object."]
    #[doc = " @param   memory[in]  The ockam memory object to deinitialize."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory received."]
    pub deinit:
        ::core::option::Option<unsafe extern "C" fn(memory: *mut ockam_memory_t) -> ockam_error_t>,
    #[doc = " @brief   Allocate memory from the specified memory module"]
    #[doc = " @param   memory[in]      The ockam memory object to use."]
    #[doc = " @param   buffer[out]     Pointer to a buffer to allocate."]
    #[doc = " @param   buffer_size[in] Buffer size (in bytes) to allocate."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory or buffer received."]
    #[doc = " @return  MEMORY_ERROR_INVALID_SIZE if buffer_size <=0."]
    pub alloc_zeroed: ::core::option::Option<
        unsafe extern "C" fn(
            memory: *mut ockam_memory_t,
            buffer: *mut *mut ::core::ffi::c_void,
            buffer_size: usize,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Free the specified buffer."]
    #[doc = " @param   memory[in]      The ockam memory object to use."]
    #[doc = " @param   buffer[in]      Buffer to free. Must have been allocated from alloc_zeroed()."]
    #[doc = " @param   buffer_size[in] Size of the buffer that was allocated. Must match what was specified in alloc_zeroed()."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory or buffer received."]
    #[doc = " @return  MEMORY_ERROR_INVALID_SIZE if buffer_size <=0."]
    pub free: ::core::option::Option<
        unsafe extern "C" fn(
            memory: *mut ockam_memory_t,
            buffer: *mut ::core::ffi::c_void,
            buffer_size: usize,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Set a set_size number of bytes to the buffer with value"]
    #[doc = " @param   memory[in]    The ockam memory object to use."]
    #[doc = " @param   buffer[out]   The buffer to fill with the specified value."]
    #[doc = " @param   value[in]     The value to set the the buffer with."]
    #[doc = " @param   set_size[in]  The number of bytes to set buffer with value."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory or buffer received."]
    #[doc = " @return  MEMORY_ERROR_INVALID_SIZE if set_size <=0."]
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            memory: *mut ockam_memory_t,
            buffer: *mut ::core::ffi::c_void,
            value: u8,
            set_size: usize,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Copy data from the source buffer to the destination buffer"]
    #[doc = " @param   memory[in]        The ockam memory object to use."]
    #[doc = " @param   destination[out]  Buffer to place the copied data into. Can not overlap with source."]
    #[doc = " @param   source[in]        Buffer to copy data from."]
    #[doc = " @param   copy_size[in]     Size of data to copy."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory, destination or source received."]
    #[doc = " @return  MEMORY_ERROR_INVALID_SIZE if copy_size <=0."]
    pub copy: ::core::option::Option<
        unsafe extern "C" fn(
            memory: *mut ockam_memory_t,
            destination: *mut ::core::ffi::c_void,
            source: *const ::core::ffi::c_void,
            copy_size: usize,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Move a move_size bytes from source to destination."]
    #[doc = " @param   memory[in]        The ockam memory object to use."]
    #[doc = " @param   destination[out]  Buffer to place the moved data into. May overlap with source."]
    #[doc = " @param   source[in]        Buffer to move data from."]
    #[doc = " @param   move_size[in]     Size of data to move."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory, destination or source received."]
    #[doc = " @return  MEMORY_ERROR_INVALID_SIZE if move_size <=0."]
    pub move_: ::core::option::Option<
        unsafe extern "C" fn(
            memory: *mut ockam_memory_t,
            destination: *mut ::core::ffi::c_void,
            source: *mut ::core::ffi::c_void,
            move_size: usize,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Compare two blocks of memory."]
    #[doc = " @param   memory[in]       The ockam memory object to use."]
    #[doc = " @param   res[out]         Result. <0\tthe first byte that does not match has a lower value in lhs than in rhs."]
    #[doc = "0\tthe contents of both memory blocks are equal."]
    #[doc = ">0\tthe first byte that does not match has a greater value in lhs than in rhs."]
    #[doc = " @param   lhs[in]          Pointer to first block of memory."]
    #[doc = " @param   rhs[in]          Pointer to second block of memory."]
    #[doc = " @param   buffer_size[in]  Size of memory blocks."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    #[doc = " @return  MEMORY_ERROR_INVALID_PARAM if invalid memory, res, lhs or rhs received."]
    pub compare: ::core::option::Option<
        unsafe extern "C" fn(
            memory: *mut ockam_memory_t,
            res: *mut ::std::os::raw::c_int,
            lhs: *const ::core::ffi::c_void,
            rhs: *const ::core::ffi::c_void,
            buffer_size: usize,
        ) -> ockam_error_t,
    >,
}
#[doc = " @struct  ockam_memory_t"]
#[doc = " @brief   The ockam memory object struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ockam_memory_t {
    pub dispatch: *mut ockam_memory_dispatch_table_t,
    pub context: *mut ::core::ffi::c_void,
}
extern "C" {
    pub static OCKAM_VAULT_INTERFACE_ERROR_DOMAIN: *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ockam_error_code_vault_interface_t {
    OCKAM_VAULT_INTERFACE_ERROR_INVALID_PARAM = 1,
}
pub type ockam_vault_t = ockam_vault;
#[repr(u32)]
#[doc = " @enum    ockam_vault_secret_t"]
#[doc = " @brief   Supported secret types for AES and Elliptic Curves."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ockam_vault_secret_type_t {
    OCKAM_VAULT_SECRET_TYPE_BUFFER = 0,
    OCKAM_VAULT_SECRET_TYPE_AES128_KEY = 1,
    OCKAM_VAULT_SECRET_TYPE_AES256_KEY = 2,
    OCKAM_VAULT_SECRET_TYPE_CURVE25519_PRIVATEKEY = 3,
    OCKAM_VAULT_SECRET_TYPE_P256_PRIVATEKEY = 4,
}
#[repr(u32)]
#[doc = " @enum    ockam_vault_secret_persistence_t"]
#[doc = " @brief   Types of secrets vault can handle."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ockam_vault_secret_persistence_t {
    OCKAM_VAULT_SECRET_EPHEMERAL = 0,
    OCKAM_VAULT_SECRET_PERSISTENT = 1,
}
#[repr(u32)]
#[doc = " @enum    ockam_vault_secret_purpose_t"]
#[doc = " @brief   Types of uses for a secret"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ockam_vault_secret_purpose_t {
    OCKAM_VAULT_SECRET_PURPOSE_KEY_AGREEMENT = 0,
}
#[doc = " @struct  ockam_vault_secret_attributes_t"]
#[doc = " @brief   Attributes for a specific ockam vault secret."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ockam_vault_secret_attributes_t {
    pub length: u16,
    pub type_: ockam_vault_secret_type_t,
    pub purpose: ockam_vault_secret_purpose_t,
    pub persistence: ockam_vault_secret_persistence_t,
}
#[doc = " @struct  ockam_vault_secret_t"]
#[doc = " @brief   Secret key data for use by Vault"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ockam_vault_secret_t {
    pub attributes: ockam_vault_secret_attributes_t,
    pub context: *mut ::core::ffi::c_void,
}
extern "C" {
    #[doc = " @brief   Deinitialize the specified ockam vault object"]
    #[doc = " @param   vault[in] The ockam vault object to deinitialize."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_vault_deinit(vault: *mut ockam_vault_t) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Generate a random number of desired size."]
    #[doc = " @param   vault[in]       Vault object to use for random number generation."]
    #[doc = " @param   buffer[out]     Buffer containing data to run through SHA-256."]
    #[doc = " @param   buffer_size[in] Size of the data to run through SHA-256."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_vault_random_bytes_generate(
        vault: *mut ockam_vault_t,
        buffer: *mut u8,
        buffer_size: usize,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Compute a SHA-256 hash based on input data."]
    #[doc = " @param   vault[in]           Vault object to use for SHA-256."]
    #[doc = " @param   input[in]           Buffer containing data to run through SHA-256."]
    #[doc = " @param   input_length[in]    Length of the data to run through SHA-256."]
    #[doc = " @param   digest[out]         Buffer to place the resulting SHA-256 hash in."]
    #[doc = " @param   digest_size[in]     Size of the digest buffer. Must be 32 bytes."]
    #[doc = " @param   digest_length[out]  Amount of data placed in the digest buffer."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_vault_sha256(
        vault: *mut ockam_vault_t,
        input: *const u8,
        input_length: usize,
        digest: *mut u8,
        digest_size: usize,
        digest_length: *mut usize,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Generate an ockam secret. Attributes struct must specify the configuration for the type of secret to"]
    #[doc = "          generate. For EC keys and AES keys, length is ignored."]
    #[doc = " @param   vault[in]       Vault object to use for generating a secret key."]
    #[doc = " @param   secret[out]     Pointer to an ockam secret object to be populated with the generated secret."]
    #[doc = " @param   attributes[in]  Desired attribtes for the secret to be generated."]
    pub fn ockam_vault_secret_generate(
        vault: *mut ockam_vault_t,
        secret: *mut ockam_vault_secret_t,
        attributes: *const ockam_vault_secret_attributes_t,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Import the specified data into the supplied ockam vault secret."]
    #[doc = " @param   vault[in]         Vault object to use for generating a secret key."]
    #[doc = " @param   secret[out]       Pointer to an ockam secret object to be populated with input data."]
    #[doc = " @param   attributes[in]    Desired attribtes for the secret being imported."]
    #[doc = " @param   input[in]         Data to load into the supplied secret."]
    #[doc = " @param   input_length[in]  Length of data to load into the secret."]
    pub fn ockam_vault_secret_import(
        vault: *mut ockam_vault_t,
        secret: *mut ockam_vault_secret_t,
        attributes: *const ockam_vault_secret_attributes_t,
        input: *const u8,
        input_length: usize,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Export data from an ockam vault secret into the supplied output buffer."]
    #[doc = " @param   vault[in]                 Vault object to use for exporting secret data."]
    #[doc = " @param   secret[in]                Ockam vault secret to export data from."]
    #[doc = " @param   output_buffer[out]        Buffer to place the exported secret data in."]
    #[doc = " @param   output_buffer_size[in]    Size of the output buffer."]
    #[doc = " @param   output_buffer_length[out] Amount of data placed in the output buffer."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_vault_secret_export(
        vault: *mut ockam_vault_t,
        secret: *mut ockam_vault_secret_t,
        output_buffer: *mut u8,
        output_buffer_size: usize,
        output_buffer_length: *mut usize,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Retrieve the public key from an ockam vault secret."]
    #[doc = " @param   vault[in]                 Vault object to use for exporting the public key"]
    #[doc = " @param   secret[in]                Ockam vault secret to export the public key for."]
    #[doc = " @param   output_buffer[out]        Buffer to place the public key in."]
    #[doc = " @param   output_buffer_size[in]    Size of the output buffer."]
    #[doc = " @param   output_buffer_length[out] Amount of data placed in the output buffer."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_vault_secret_publickey_get(
        vault: *mut ockam_vault_t,
        secret: *mut ockam_vault_secret_t,
        output_buffer: *mut u8,
        output_buffer_size: usize,
        output_buffer_length: *mut usize,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Retrive the attributes for a specified secret"]
    #[doc = " @param   vault[in]               Vault object to use for retrieving ockam vault secret attributes."]
    #[doc = " @param   secret[in]              Ockam vault secret to get attributes for."]
    #[doc = " @param   secret_attributes[out]  Pointer to the attributes for the specified secret."]
    pub fn ockam_vault_secret_attributes_get(
        vault: *mut ockam_vault_t,
        secret: *mut ockam_vault_secret_t,
        attributes: *mut ockam_vault_secret_attributes_t,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Set or change the type of secret. Note: EC secrets can not be changed."]
    #[doc = " @param   vault[in]   Vault object to use for setting secret type."]
    #[doc = " @param   secret[in]  Secret to change the type."]
    #[doc = " @param   type[in]    Type of secret to change to."]
    pub fn ockam_vault_secret_type_set(
        vault: *mut ockam_vault_t,
        secret: *mut ockam_vault_secret_t,
        type_: ockam_vault_secret_type_t,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Delete an ockam vault secret."]
    #[doc = " @param   vault[in]   Vault object to use for deleting the ockam vault secret."]
    #[doc = " @param   secret[in]  Ockam vault secret to delete."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_vault_secret_destroy(
        vault: *mut ockam_vault_t,
        secret: *mut ockam_vault_secret_t,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Perform an ECDH operation on the supplied ockam vault secret and peer_publickey. The result is another"]
    #[doc = "          ockam vault secret of type unknown."]
    #[doc = " @param   vault[in]                 Vault object to use for encryption."]
    #[doc = " @param   privatekey[in]            The ockam vault secret to use for the private key of ECDH."]
    #[doc = " @param   peer_publickey[in]        Public key data to use for ECDH."]
    #[doc = " @param   peer_publickey_length[in] Length of the public key."]
    #[doc = " @param   shared_secret[out]        Resulting shared secret from a sucessful ECDH operation. Invalid if ECDH failed."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_vault_ecdh(
        vault: *mut ockam_vault_t,
        privatekey: *mut ockam_vault_secret_t,
        peer_publickey: *const u8,
        peer_publickey_length: usize,
        shared_secret: *mut ockam_vault_secret_t,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Perform an HMAC-SHA256 based key derivation function on the supplied salt and input key material."]
    #[doc = " @param   vault[in]                 Vault object to use for encryption."]
    #[doc = " @param   salt[in]                  Ockam vault secret containing the salt for HKDF."]
    #[doc = " @param   input_key_material[in]    Ockam vault secret containing input key material to use for HKDF."]
    #[doc = " @param   derived_outputs_count[in] Total number of keys to generate."]
    #[doc = " @param   derived_outputs[out]      Array of ockam vault secrets resulting from HKDF."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_vault_hkdf_sha256(
        vault: *mut ockam_vault_t,
        salt: *mut ockam_vault_secret_t,
        input_key_material: *mut ockam_vault_secret_t,
        derived_outputs_count: u8,
        derived_outputs: *mut ockam_vault_secret_t,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Encrypt a payload using AES-GCM."]
    #[doc = " @param   vault[in]                       Vault object to use for encryption."]
    #[doc = " @param   key[in]                         Ockam secret key to use for encryption."]
    #[doc = " @param   nonce[in]                       Nonce value to use for encryption."]
    #[doc = " @param   additional_data[in]             Additional data to use for encryption."]
    #[doc = " @param   additional_data_length[in]      Length of the additional data."]
    #[doc = " @param   plaintext[in]                   Buffer containing plaintext data to encrypt."]
    #[doc = " @param   plaintext_length[in]            Length of plaintext data to encrypt."]
    #[doc = " @param   ciphertext_and_tag[in]          Buffer containing the generated ciphertext and tag data."]
    #[doc = " @param   ciphertext_and_tag_size[in]     Size of the ciphertext + tag buffer. Must be plaintext_size + 16."]
    #[doc = " @param   ciphertext_and_tag_length[out]  Amount of data placed in the ciphertext + tag buffer."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_vault_aead_aes_gcm_encrypt(
        vault: *mut ockam_vault_t,
        key: *mut ockam_vault_secret_t,
        nonce: u16,
        additional_data: *const u8,
        additional_data_length: usize,
        plaintext: *const u8,
        plaintext_length: usize,
        ciphertext_and_tag: *mut u8,
        ciphertext_and_tag_size: usize,
        ciphertext_and_tag_length: *mut usize,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Decrypt a payload using AES-GCM."]
    #[doc = " @param   vault[in]                     Vault object to use for decryption."]
    #[doc = " @param   key[in]                       Ockam secret key to use for decryption."]
    #[doc = " @param   nonce[in]                     Nonce value to use for decryption."]
    #[doc = " @param   additional_data[in]           Additional data to use for decryption."]
    #[doc = " @param   additional_data_length[in]    Length of the additional data."]
    #[doc = " @param   ciphertext_and_tag[in]        The ciphertext + tag data to decrypt."]
    #[doc = " @param   ciphertext_and_tag_length[in] Length of the ciphertext + tag data to decrypt."]
    #[doc = " @param   plaintext[out]                Buffer to place the decrypted data in."]
    #[doc = " @param   plaintext_size[in]            Size of the plaintext buffer. Must be ciphertext_tag_size - 16."]
    #[doc = " @param   plaintext_length[out]         Amount of data placed in the plaintext buffer."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_vault_aead_aes_gcm_decrypt(
        vault: *mut ockam_vault_t,
        key: *mut ockam_vault_secret_t,
        nonce: u16,
        additional_data: *const u8,
        additional_data_length: usize,
        ciphertext_and_tag: *const u8,
        ciphertext_and_tag_length: usize,
        plaintext: *mut u8,
        plaintext_size: usize,
        plaintext_length: *mut usize,
    ) -> ockam_error_t;
}
extern "C" {
    pub static OCKAM_MUTEX_INTERFACE_ERROR_DOMAIN: *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ockam_error_code_mutex_interface_t {
    OCKAM_MUTEX_INTERFACE_ERROR_INVALID_PARAM = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ockam_mutex_t {
    _unused: [u8; 0],
}
pub type ockam_mutex_lock_t = *mut ::core::ffi::c_void;
extern "C" {
    #[doc = " @brief   Deinitialize the specified ockam mutex object."]
    #[doc = " @param   mutex[in]  The ockam mutex object to deinitialize."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_mutex_deinit(mutex: *mut ockam_mutex_t) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Allocate mutex from the specified mutex module"]
    #[doc = " @param   mutex[in]"]
    #[doc = " @param   lock[in]"]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_mutex_create(
        mutex: *mut ockam_mutex_t,
        lock: *mut ockam_mutex_lock_t,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Destroy the specified mutex lock object."]
    #[doc = " @param   mutex[in]"]
    #[doc = " @param   lock[in]"]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_mutex_destroy(
        mutex: *mut ockam_mutex_t,
        lock: ockam_mutex_lock_t,
    ) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Lock the specified lock object."]
    #[doc = " @param   mutex[in]"]
    #[doc = " @param   lock[in]"]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_mutex_lock(mutex: *mut ockam_mutex_t, lock: ockam_mutex_lock_t) -> ockam_error_t;
}
extern "C" {
    #[doc = " @brief   Unlock the specified lock object."]
    #[doc = " @param   mutex[in]"]
    #[doc = " @param   lock[in]"]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub fn ockam_mutex_unlock(mutex: *mut ockam_mutex_t, lock: ockam_mutex_lock_t)
        -> ockam_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ockam_vault_dispatch_table_t {
    #[doc = " @brief   Deinitialize the specified ockam vault object"]
    #[doc = " @param   vault[in] The ockam vault object to deinitialize."]
    pub deinit:
        ::core::option::Option<unsafe extern "C" fn(vault: *mut ockam_vault_t) -> ockam_error_t>,
    #[doc = " @brief   Generate a random number of desired size."]
    #[doc = " @param   vault[in]       Vault object to use for random number generation."]
    #[doc = " @param   buffer[out]     Buffer containing data to run through SHA-256."]
    #[doc = " @param   buffer_size[in] Size of the data to run through SHA-256."]
    pub random: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            buffer: *mut u8,
            buffer_size: usize,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Compute a SHA-256 hash based on input data."]
    #[doc = " @param   vault[in]           Vault object to use for SHA-256."]
    #[doc = " @param   input[in]           Buffer containing data to run through SHA-256."]
    #[doc = " @param   input_length[in]    Length of the data to run through SHA-256."]
    #[doc = " @param   digest[out]         Buffer to place the resulting SHA-256 hash in."]
    #[doc = " @param   digest_size[in]     Size of the digest buffer. Must be 32 bytes."]
    #[doc = " @param   digest_length[out]  Amount of data placed in the digest buffer."]
    pub sha256: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            input: *const u8,
            input_length: usize,
            digest: *mut u8,
            digest_size: usize,
            digest_length: *mut usize,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Generate an ockam secret."]
    #[doc = " @param   vault[in]       Vault object to use for generating a secret key."]
    #[doc = " @param   secret[out]     Pointer to an ockam secret object to be populated with the generated secret."]
    #[doc = " @param   attributes[in]  Desired attribtes for the secret to be generated."]
    pub secret_generate: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            secret: *mut ockam_vault_secret_t,
            attributes: *const ockam_vault_secret_attributes_t,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Import the specified data into the supplied ockam vault secret."]
    #[doc = " @param   vault[in]         Vault object to use for generating a secret key."]
    #[doc = " @param   secret[out]       Pointer to an ockam secret object to be populated with input data."]
    #[doc = " @param   attributes[in]    Desired attribtes for the secret to be imported."]
    #[doc = " @param   input[in]         Data to load into the supplied secret."]
    #[doc = " @param   input_length[in]  Length of data to load into the secret."]
    pub secret_import: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            secret: *mut ockam_vault_secret_t,
            attributes: *const ockam_vault_secret_attributes_t,
            input: *const u8,
            input_length: usize,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Export data from an ockam vault secret into the supplied output buffer."]
    #[doc = " @param   vault[in]                 Vault object to use for exporting secret data."]
    #[doc = " @param   secret[in]                Ockam vault secret to export data from."]
    #[doc = " @param   output_buffer[out]        Buffer to place the exported secret data in."]
    #[doc = " @param   output_buffer_size[in]    Size of the output buffer."]
    #[doc = " @param   output_buffer_length[out] Amount of data placed in the output buffer."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub secret_export: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            secret: *mut ockam_vault_secret_t,
            output_buffer: *mut u8,
            output_buffer_size: usize,
            output_buffer_length: *mut usize,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Retrieve the public key from an ockam vault secret."]
    #[doc = " @param   vault[in]                 Vault object to use for exporting the public key"]
    #[doc = " @param   secret[in]                Ockam vault secret to export the public key for."]
    #[doc = " @param   output_buffer[out]        Buffer to place the public key in."]
    #[doc = " @param   output_buffer_size[in]    Size of the output buffer."]
    #[doc = " @param   output_buffer_length[out] Amount of data placed in the output buffer."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub secret_publickey_get: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            secret: *mut ockam_vault_secret_t,
            output_buffer: *mut u8,
            output_buffer_size: usize,
            output_buffer_length: *mut usize,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Retrive the attributes for a specified secret"]
    #[doc = " @param   vault[in]       Vault object to use for retrieving ockam vault secret attributes."]
    #[doc = " @param   secret[in]      Ockam vault secret to get attributes for."]
    #[doc = " @param   attributes[out] Pointer to the attributes for the specified secret."]
    pub secret_attributes_get: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            secret: *mut ockam_vault_secret_t,
            attributes: *mut ockam_vault_secret_attributes_t,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Set or change the type of secret. Note: EC secrets can not be changed."]
    #[doc = " @param   vault[in]   Vault object to use for setting secret type."]
    #[doc = " @param   secret[in]  Secret to change the type."]
    #[doc = " @param   type[in]    Type of secret to change to."]
    pub secret_type_set: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            secret: *mut ockam_vault_secret_t,
            type_: ockam_vault_secret_type_t,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Delete an ockam vault secret."]
    #[doc = " @param   vault[in]   Vault object to use for deleting the ockam vault secret."]
    #[doc = " @param   secret[in]  Ockam vault secret to delete."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub secret_destroy: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            secret: *mut ockam_vault_secret_t,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Perform an ECDH operation on the supplied ockam vault secret and peer_publickey. The result is another"]
    #[doc = "          ockam vault secret of type unknown."]
    #[doc = " @param   vault[in]                 Vault object to use for encryption."]
    #[doc = " @param   privatekey[in]            The ockam vault secret to use for the private key of ECDH."]
    #[doc = " @param   peer_publickey[in]        Public key data to use for ECDH."]
    #[doc = " @param   peer_publickey_length[in] Length of the public key."]
    #[doc = " @param   shared_secret[out]        Resulting shared secret from a sucessful ECDH operation. Invalid if ECDH failed."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub ecdh: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            privatekey: *mut ockam_vault_secret_t,
            peer_publickey: *const u8,
            peer_publickey_length: usize,
            shared_secret: *mut ockam_vault_secret_t,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Perform an HMAC-SHA256 based key derivation function on the supplied salt and input key material."]
    #[doc = " @param   vault[in]                 Vault object to use for encryption."]
    #[doc = " @param   salt[in]                  Ockam vault secret containing the salt for HKDF."]
    #[doc = " @param   input_key_material[in]    Ockam vault secret containing input key material to use for HKDF."]
    #[doc = " @param   derived_outputs_count[in] Total number of keys to generate."]
    #[doc = " @param   derived_outputs[out]      Array of ockam vault secrets resulting from HKDF."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub hkdf_sha256: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            salt: *mut ockam_vault_secret_t,
            input_key_material: *mut ockam_vault_secret_t,
            derived_outputs_count: u8,
            derived_outputs: *mut ockam_vault_secret_t,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Encrypt a payload using AES-GCM."]
    #[doc = " @param   vault[in]                       Vault object to use for encryption."]
    #[doc = " @param   key[in]                         Ockam secret key to use for encryption."]
    #[doc = " @param   nonce[in]                       Nonce value to use for encryption."]
    #[doc = " @param   additional_data[in]             Additional data to use for encryption."]
    #[doc = " @param   additional_data_length[in]      Length of the additional data."]
    #[doc = " @param   plaintext[in]                   Buffer containing plaintext data to encrypt."]
    #[doc = " @param   plaintext_length[in]            Length of plaintext data to encrypt."]
    #[doc = " @param   ciphertext_and_tag[in]          Buffer containing the generated ciphertext and tag data."]
    #[doc = " @param   ciphertext_and_tag_size[in]     Size of the ciphertext + tag buffer. Must be plaintext_size + 16."]
    #[doc = " @param   ciphertext_and_tag_length[out]  Amount of data placed in the ciphertext + tag buffer."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub aead_aes_gcm_encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            key: *mut ockam_vault_secret_t,
            nonce: u16,
            additional_data: *const u8,
            additional_data_length: usize,
            plaintext: *const u8,
            plaintext_length: usize,
            ciphertext_and_tag: *mut u8,
            ciphertext_and_tag_size: usize,
            ciphertext_and_tag_length: *mut usize,
        ) -> ockam_error_t,
    >,
    #[doc = " @brief   Decrypt a payload using AES-GCM."]
    #[doc = " @param   vault[in]                     Vault object to use for decryption."]
    #[doc = " @param   key[in]                       Ockam secret key to use for decryption."]
    #[doc = " @param   nonce[in]                     Nonce value to use for decryption."]
    #[doc = " @param   additional_data[in]           Additional data to use for decryption."]
    #[doc = " @param   additional_data_length[in]    Length of the additional data."]
    #[doc = " @param   ciphertext_and_tag[in]        The ciphertext + tag data to decrypt."]
    #[doc = " @param   ciphertext_and_tag_length[in] Length of the ciphertext + tag data to decrypt."]
    #[doc = " @param   plaintext[out]                Buffer to place the decrypted data in."]
    #[doc = " @param   plaintext_size[in]            Size of the plaintext buffer. Must be ciphertext_tag_size - 16."]
    #[doc = " @param   plaintext_length[out]         Amount of data placed in the plaintext buffer."]
    #[doc = " @return  OCKAM_ERROR_NONE on success."]
    pub aead_aes_gcm_decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            vault: *mut ockam_vault_t,
            key: *mut ockam_vault_secret_t,
            nonce: u16,
            additional_data: *const u8,
            additional_data_length: usize,
            ciphertext_and_tag: *const u8,
            ciphertext_and_tag_length: usize,
            plaintext: *mut u8,
            plaintext_size: usize,
            plaintext_length: *mut usize,
        ) -> ockam_error_t,
    >,
}
#[doc = " @struct  ockam_vault_t"]
#[doc = " @brief"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ockam_vault {
    pub dispatch: *mut ockam_vault_dispatch_table_t,
    pub default_context: *mut ::core::ffi::c_void,
    pub impl_context: *mut ::core::ffi::c_void,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ATCA_STATUS {
    #[doc = "!< Function succeeded."]
    ATCA_SUCCESS = 0,
    ATCA_CONFIG_ZONE_LOCKED = 1,
    ATCA_DATA_ZONE_LOCKED = 2,
    #[doc = "!< response status byte indicates CheckMac failure (status byte = 0x01)"]
    ATCA_WAKE_FAILED = 208,
    #[doc = "!< response status byte indicates CheckMac failure (status byte = 0x01)"]
    ATCA_CHECKMAC_VERIFY_FAILED = 209,
    #[doc = "!< response status byte indicates parsing error (status byte = 0x03)"]
    ATCA_PARSE_ERROR = 210,
    #[doc = "!< response status byte indicates DEVICE did not receive data properly (status byte = 0xFF)"]
    ATCA_STATUS_CRC = 212,
    #[doc = "!< response status byte is unknown"]
    ATCA_STATUS_UNKNOWN = 213,
    #[doc = "!< response status byte is ECC fault (status byte = 0x05)"]
    ATCA_STATUS_ECC = 214,
    #[doc = "!< response status byte is Self Test Error, chip in failure mode (status byte = 0x07)"]
    ATCA_STATUS_SELFTEST_ERROR = 215,
    #[doc = "!< Function could not execute due to incorrect condition / state."]
    ATCA_FUNC_FAIL = 224,
    #[doc = "!< unspecified error"]
    ATCA_GEN_FAIL = 225,
    #[doc = "!< bad argument (out of range, null pointer, etc.)"]
    ATCA_BAD_PARAM = 226,
    #[doc = "!< invalid device id, id not set"]
    ATCA_INVALID_ID = 227,
    #[doc = "!< Count value is out of range or greater than buffer size."]
    ATCA_INVALID_SIZE = 228,
    #[doc = "!< CRC error in data received from device"]
    ATCA_RX_CRC_ERROR = 229,
    #[doc = "!< Timed out while waiting for response. Number of bytes received is > 0."]
    ATCA_RX_FAIL = 230,
    #[doc = "!< Not an error while the Command layer is polling for a command response."]
    ATCA_RX_NO_RESPONSE = 231,
    #[doc = "!< Re-synchronization succeeded, but only after generating a Wake-up"]
    ATCA_RESYNC_WITH_WAKEUP = 232,
    #[doc = "!< for protocols needing parity"]
    ATCA_PARITY_ERROR = 233,
    #[doc = "!< for Microchip PHY protocol, timeout on transmission waiting for master"]
    ATCA_TX_TIMEOUT = 234,
    #[doc = "!< for Microchip PHY protocol, timeout on receipt waiting for master"]
    ATCA_RX_TIMEOUT = 235,
    #[doc = "!< Device did not respond too many times during a transmission. Could indicate no device present."]
    ATCA_TOO_MANY_COMM_RETRIES = 236,
    #[doc = "!< Supplied buffer is too small for data required"]
    ATCA_SMALL_BUFFER = 237,
    #[doc = "!< Communication with device failed. Same as in hardware dependent modules."]
    ATCA_COMM_FAIL = 240,
    #[doc = "!< Timed out while waiting for response. Number of bytes received is 0."]
    ATCA_TIMEOUT = 241,
    #[doc = "!< opcode is not supported by the device"]
    ATCA_BAD_OPCODE = 242,
    #[doc = "!< received proper wake token"]
    ATCA_WAKE_SUCCESS = 243,
    #[doc = "!< chip was in a state where it could not execute the command, response status byte indicates command execution error (status byte = 0x0F)"]
    ATCA_EXECUTION_ERROR = 244,
    #[doc = "!< Function or some element of it hasn't been implemented yet"]
    ATCA_UNIMPLEMENTED = 245,
    #[doc = "!< Code failed run-time consistency check"]
    ATCA_ASSERT_FAILURE = 246,
    #[doc = "!< Failed to write"]
    ATCA_TX_FAIL = 247,
    #[doc = "!< required zone was not locked"]
    ATCA_NOT_LOCKED = 248,
    #[doc = "!< For protocols that support device discovery (kit protocol), no devices were found"]
    ATCA_NO_DEVICES = 249,
    #[doc = "!< random number generator health test error"]
    ATCA_HEALTH_TEST_ERROR = 250,
    #[doc = "!< Couldn't allocate required memory"]
    ATCA_ALLOC_FAILURE = 251,
    #[doc = "!< Use flags on the device indicates its consumed fully"]
    ATCA_USE_FLAGS_CONSUMED = 252,
}
#[repr(u32)]
#[doc = " \\brief The supported Device type in Cryptoauthlib library"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ATCADeviceType {
    ATSHA204A = 0,
    ATECC108A = 1,
    ATECC508A = 2,
    ATECC608A = 3,
    ATSHA206A = 4,
    ATCA_DEV_UNKNOWN = 32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ATCAIfaceType {
    ATCA_I2C_IFACE = 0,
    ATCA_SWI_IFACE = 1,
    ATCA_UART_IFACE = 2,
    ATCA_SPI_IFACE = 3,
    ATCA_HID_IFACE = 4,
    ATCA_CUSTOM_IFACE = 5,
    ATCA_UNKNOWN_IFACE = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ATCAKitType {
    ATCA_KIT_AUTO_IFACE = 0,
    ATCA_KIT_I2C_IFACE = 1,
    ATCA_KIT_SWI_IFACE = 2,
    ATCA_KIT_UNKNOWN_IFACE = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ATCAIfaceCfg {
    pub iface_type: ATCAIfaceType,
    pub devtype: ATCADeviceType,
    pub __bindgen_anon_1: ATCAIfaceCfg__bindgen_ty_1,
    pub wake_delay: u16,
    pub rx_retries: ::std::os::raw::c_int,
    pub cfg_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ATCAIfaceCfg__bindgen_ty_1 {
    pub atcai2c: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1,
    pub atcaswi: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2,
    pub atcauart: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3,
    pub atcahid: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4,
    pub atcacustom: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5,
    _bindgen_union_align: [u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1 {
    pub slave_address: u8,
    pub bus: u8,
    pub baud: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2 {
    pub bus: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3 {
    pub port: ::std::os::raw::c_int,
    pub baud: u32,
    pub wordsize: u8,
    pub parity: u8,
    pub stopbits: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4 {
    pub idx: ::std::os::raw::c_int,
    pub dev_interface: ATCAKitType,
    pub dev_identity: u8,
    pub vid: u32,
    pub pid: u32,
    pub packetsize: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5 {
    pub halinit: ::core::option::Option<
        unsafe extern "C" fn(
            hal: *mut ::core::ffi::c_void,
            cfg: *mut ::core::ffi::c_void,
        ) -> ATCA_STATUS,
    >,
    pub halpostinit: ::core::option::Option<
        unsafe extern "C" fn(iface: *mut ::core::ffi::c_void) -> ATCA_STATUS,
    >,
    pub halsend: ::core::option::Option<
        unsafe extern "C" fn(
            iface: *mut ::core::ffi::c_void,
            txdata: *mut u8,
            txlength: ::std::os::raw::c_int,
        ) -> ATCA_STATUS,
    >,
    pub halreceive: ::core::option::Option<
        unsafe extern "C" fn(
            iface: *mut ::core::ffi::c_void,
            rxdata: *mut u8,
            rxlength: *mut u16,
        ) -> ATCA_STATUS,
    >,
    pub halwake: ::core::option::Option<
        unsafe extern "C" fn(iface: *mut ::core::ffi::c_void) -> ATCA_STATUS,
    >,
    pub halidle: ::core::option::Option<
        unsafe extern "C" fn(iface: *mut ::core::ffi::c_void) -> ATCA_STATUS,
    >,
    pub halsleep: ::core::option::Option<
        unsafe extern "C" fn(iface: *mut ::core::ffi::c_void) -> ATCA_STATUS,
    >,
    pub halrelease: ::core::option::Option<
        unsafe extern "C" fn(hal_data: *mut ::core::ffi::c_void) -> ATCA_STATUS,
    >,
}
extern "C" {
    pub static OCKAM_VAULT_ATECC608A_ERROR_DOMAIN: *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ockam_error_code_vault_atecc608a_t {
    OCKAM_VAULT_ATECC608A_ERROR_INVALID_PARAM = 1,
    OCKAM_VAULT_ATECC608A_ERROR_INVALID_ATTRIBUTES = 2,
    OCKAM_VAULT_ATECC608A_ERROR_INIT_FAIL = 3,
    OCKAM_VAULT_ATECC608A_ERROR_INVALID_CONTEXT = 4,
    OCKAM_VAULT_ATECC608A_ERROR_INVALID_SIZE = 5,
    OCKAM_VAULT_ATECC608A_ERROR_RANDOM_FAIL = 6,
    OCKAM_VAULT_ATECC608A_ERROR_SHA256_FAIL = 7,
    OCKAM_VAULT_ATECC608A_ERROR_INVALID_SECRET = 8,
    OCKAM_VAULT_ATECC608A_ERROR_SECRET_GENERATE_FAIL = 9,
    OCKAM_VAULT_ATECC608A_ERROR_SECRET_IMPORT_FAIL = 10,
    OCKAM_VAULT_ATECC608A_ERROR_ECDH_FAIL = 11,
    OCKAM_VAULT_ATECC608A_ERROR_PUBLIC_KEY_FAIL = 12,
    OCKAM_VAULT_ATECC608A_ERROR_INVALID_SECRET_TYPE = 13,
    OCKAM_VAULT_ATECC608A_ERROR_HKDF_SHA256_FAIL = 14,
    OCKAM_VAULT_ATECC608A_ERROR_AEAD_AES_GCM_FAIL = 15,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ockam_vault_atecc608a_io_protection_t {
    pub key: [u8; 32usize],
    pub key_size: u8,
    pub slot: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ockam_vault_atecc608a_attributes_t {
    pub memory: *mut ockam_memory_t,
    pub mutex: *mut ockam_mutex_t,
    pub atca_iface_cfg: *mut ATCAIfaceCfg,
    pub io_protection: *mut ockam_vault_atecc608a_io_protection_t,
}
extern "C" {
    pub fn ockam_vault_atecc608a_init(
        vault: *mut ockam_vault_t,
        attributes: *mut ockam_vault_atecc608a_attributes_t,
    ) -> ockam_error_t;
}
