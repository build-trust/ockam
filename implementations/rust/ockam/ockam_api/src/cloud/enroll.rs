use std::borrow::Cow;

use minicbor::{Decode, Encode};
use serde::{Deserialize, Serialize};

#[cfg(feature = "tag")]
use ockam_core::TypeTag;

#[derive(Encode, Decode, Serialize, Deserialize, Debug, Clone)]
#[cfg_attr(test, derive(PartialEq, Eq))]
#[cbor(transparent)]
#[serde(transparent)]
pub struct Token(#[n(0)] pub String);

impl Token {
    pub fn new(token: impl Into<String>) -> Self {
        Self(token.into())
    }
}

mod node {
    use std::time::Duration;

    use minicbor::Decoder;
    use tracing::trace;

    use ockam::identity::credential::Attributes;
    use ockam_core::api::Request;
    use ockam_core::{self, Result};
    use ockam_multiaddr::MultiAddr;
    use ockam_node::Context;

    use crate::cloud::enroll::auth0::{AuthenticateOidcToken, OidcToken};
    use crate::cloud::enroll::enrollment_token::{EnrollmentToken, RequestEnrollmentToken};
    use crate::cloud::{CloudRequestWrapper, ORCHESTRATOR_RESTART_TIMEOUT};
    use crate::nodes::{NodeManager, NodeManagerWorker};

    const TARGET: &str = "ockam_api::cloud::enroll";

    impl NodeManager {
        /// Executes an enrollment process to generate a new set of access tokens using the auth0 flow.
        pub async fn enroll_auth0(
            &self,
            ctx: &Context,
            route: &MultiAddr,
            token: OidcToken,
        ) -> Result<()> {
            let request = CloudRequestWrapper::new(AuthenticateOidcToken::new(token), route, None);
            self.enroll_auth0_response(ctx, request).await?;
            Ok(())
        }

        /// Executes an enrollment process to generate a new set of access tokens using the auth0 flow.
        pub(crate) async fn enroll_auth0_response(
            &self,
            ctx: &Context,
            req_wrapper: CloudRequestWrapper<AuthenticateOidcToken>,
        ) -> Result<Vec<u8>> {
            let route = req_wrapper.multiaddr()?;
            let req_builder = Request::post("v0/enroll").body(req_wrapper.req);
            let api_service = "auth0_authenticator";

            trace!(target: TARGET, "executing auth0 flow");

            self.request_controller_with_timeout(
                ctx,
                api_service,
                None,
                &route,
                api_service,
                req_builder,
                None,
                Duration::from_secs(ORCHESTRATOR_RESTART_TIMEOUT),
            )
            .await
        }
    }

    impl NodeManagerWorker {
        /// Executes an enrollment process to generate a new set of access tokens using the auth0 flow.
        pub async fn enroll_auth0_response(
            &self,
            ctx: &Context,
            req_wrapper: CloudRequestWrapper<AuthenticateOidcToken>,
        ) -> Result<Vec<u8>> {
            let node_manager = self.inner().read().await;
            node_manager.enroll_auth0_response(ctx, req_wrapper).await
        }

        /// Generates a token that will be associated to the passed attributes.
        pub(crate) async fn generate_enrollment_token(
            &mut self,
            ctx: &mut Context,
            dec: &mut Decoder<'_>,
        ) -> Result<Vec<u8>> {
            let req_wrapper: CloudRequestWrapper<Attributes> = dec.decode()?;
            let cloud_multiaddr = req_wrapper.multiaddr()?;
            let req_body: Attributes = req_wrapper.req;
            let req_body = RequestEnrollmentToken::new(req_body);

            let label = "enrollment_token_generator";
            trace!(target: TARGET, "generating tokens");

            let req_builder = Request::post("v0/").body(req_body);

            self.request_controller(
                ctx,
                label,
                "request_enrollment_token",
                &cloud_multiaddr,
                "projects",
                req_builder,
                None,
            )
            .await
        }

        /// Authenticates a token generated by `generate_enrollment_token`.
        pub(crate) async fn authenticate_enrollment_token(
            &mut self,
            ctx: &mut Context,
            dec: &mut Decoder<'_>,
        ) -> Result<Vec<u8>> {
            let req_wrapper: CloudRequestWrapper<EnrollmentToken> = dec.decode()?;
            let cloud_multiaddr = req_wrapper.multiaddr()?;
            let req_body: EnrollmentToken = req_wrapper.req;
            let req_builder = Request::post("v0/enroll").body(req_body);
            let api_service = "enrollment_token_authenticator";

            trace!(target: TARGET, "authenticating token");
            self.request_controller_with_timeout(
                ctx,
                api_service,
                None,
                &cloud_multiaddr,
                api_service,
                req_builder,
                None,
                Duration::from_secs(ORCHESTRATOR_RESTART_TIMEOUT),
            )
            .await
        }
    }
}

pub mod auth0 {
    use super::*;

    // Req/Res types

    #[derive(serde::Deserialize, Debug, PartialEq, Eq)]
    pub struct DeviceCode<'a> {
        pub device_code: Cow<'a, str>,
        pub user_code: Cow<'a, str>,
        pub verification_uri: Cow<'a, str>,
        pub verification_uri_complete: Cow<'a, str>,
        pub expires_in: usize,
        pub interval: usize,
    }

    #[derive(serde::Deserialize, Debug, PartialEq, Eq)]
    pub struct AuthorizationCode {
        pub code: String,
    }

    impl AuthorizationCode {
        pub fn new(s: impl Into<String>) -> Self {
            Self { code: s.into() }
        }
    }

    #[derive(serde::Deserialize, Debug, PartialEq, Eq)]
    pub struct TokensError<'a> {
        pub error: Cow<'a, str>,
        pub error_description: Cow<'a, str>,
    }

    #[derive(serde::Deserialize, Debug, Clone)]
    #[cfg_attr(test, derive(PartialEq, Eq))]
    pub struct OidcToken {
        pub token_type: TokenType,
        pub access_token: Token,
    }

    #[derive(serde::Serialize, serde::Deserialize, Debug, Clone, Eq, PartialEq)]
    #[cfg_attr(test, derive(Default))]
    pub struct UserInfo {
        pub sub: String,
        pub nickname: String,
        pub name: String,
        pub picture: String,
        pub updated_at: String,
        pub email: String,
        pub email_verified: bool,
    }

    #[derive(Encode, Decode, Debug)]
    #[cfg_attr(test, derive(Clone))]
    #[rustfmt::skip]
    #[cbor(map)]
    pub struct AuthenticateOidcToken {
        #[cfg(feature = "tag")]
        #[n(0)] pub tag: TypeTag<1058055>,
        #[n(1)] pub token_type: TokenType,
        #[n(2)] pub access_token: Token,
    }

    impl AuthenticateOidcToken {
        pub fn new(token: OidcToken) -> Self {
            Self {
                #[cfg(feature = "tag")]
                tag: TypeTag,
                token_type: token.token_type,
                access_token: token.access_token,
            }
        }
    }

    // Auxiliary types

    #[derive(serde::Deserialize, Encode, Decode, Debug, Clone)]
    #[cfg_attr(test, derive(PartialEq, Eq))]
    #[rustfmt::skip]
    #[cbor(index_only)]
    pub enum TokenType {
        #[n(0)] Bearer,
    }
}

pub mod enrollment_token {
    use serde::Serialize;

    use ockam::identity::credential::Attributes;

    use super::*;

    // Main req/res types

    #[derive(Encode, Debug)]
    #[cfg_attr(test, derive(Decode, Clone))]
    #[rustfmt::skip]
    #[cbor(map)]
    pub struct RequestEnrollmentToken {
        #[cfg(feature = "tag")]
        #[n(0)] pub tag: TypeTag<8560526>,
        #[b(1)] pub attributes: Attributes,
    }

    impl RequestEnrollmentToken {
        pub fn new(attributes: Attributes) -> Self {
            Self {
                #[cfg(feature = "tag")]
                tag: TypeTag,
                attributes,
            }
        }
    }

    #[derive(Encode, Decode, Serialize, Debug)]
    #[cfg_attr(test, derive(Clone))]
    #[rustfmt::skip]
    #[cbor(map)]
    pub struct EnrollmentToken {
        #[cfg(feature = "tag")]
        #[serde(skip)]
        #[n(0)] pub tag: TypeTag<8932763>,
        #[n(1)] pub token: Token,
    }

    impl EnrollmentToken {
        pub fn new(token: Token) -> Self {
            Self {
                #[cfg(feature = "tag")]
                tag: TypeTag,
                token,
            }
        }
    }

    #[derive(Encode, Debug)]
    #[cfg_attr(test, derive(Decode, Clone))]
    #[rustfmt::skip]
    #[cbor(map)]
    pub struct AuthenticateEnrollmentToken {
        #[cfg(feature = "tag")]
        #[n(0)] pub tag: TypeTag<9463780>,
        #[n(1)] pub token: Token,
    }

    impl AuthenticateEnrollmentToken {
        pub fn new(token: EnrollmentToken) -> Self {
            Self {
                #[cfg(feature = "tag")]
                tag: TypeTag,
                token: token.token,
            }
        }
    }
}
